// This file is generated by rust-protobuf 2.18.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `src/aesm-proto.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_0;

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request {
    // message fields
    pub initQuoteReq: ::protobuf::SingularPtrField<Request_InitQuoteRequest>,
    pub getQuoteReq: ::protobuf::SingularPtrField<Request_GetQuoteRequest>,
    pub getLicTokenReq: ::protobuf::SingularPtrField<Request_GetLaunchTokenRequest>,
    pub reportErrReq: ::protobuf::SingularPtrField<Request_ReportAttestationErrorRequest>,
    pub getWhiteListSizeReq: ::protobuf::SingularPtrField<Request_GetWhiteListSizeRequest>,
    pub getWhiteListReq: ::protobuf::SingularPtrField<Request_GetWhiteListRequest>,
    pub sgxGetExtendedEpidGroupIdReq: ::protobuf::SingularPtrField<Request_SGXGetExtendedEpidGroupIdRequest>,
    pub sgxSwitchExtendedEpidGroupReq: ::protobuf::SingularPtrField<Request_SGXSwitchExtendedEpidGroupRequest>,
    pub sgxRegisterReq: ::protobuf::SingularPtrField<Request_SGXRegisterRequest>,
    pub initQuoteExReq: ::protobuf::SingularPtrField<Request_InitQuoteExRequest>,
    pub getQuoteSizeExReq: ::protobuf::SingularPtrField<Request_GetQuoteSizeExRequest>,
    pub getQuoteExReq: ::protobuf::SingularPtrField<Request_GetQuoteExRequest>,
    pub checkUpdateStatusReq: ::protobuf::SingularPtrField<Request_CheckUpdateStatusRequest>,
    pub selectAttKeyIDReq: ::protobuf::SingularPtrField<Request_SelectAttKeyIDRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request {
    fn default() -> &'a Request {
        <Request as ::protobuf::Message>::default_instance()
    }
}

impl Request {
    pub fn new() -> Request {
        ::std::default::Default::default()
    }

    // optional .aesm.message.Request.InitQuoteRequest initQuoteReq = 1;


    pub fn get_initQuoteReq(&self) -> &Request_InitQuoteRequest {
        self.initQuoteReq.as_ref().unwrap_or_else(|| <Request_InitQuoteRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_initQuoteReq(&mut self) {
        self.initQuoteReq.clear();
    }

    pub fn has_initQuoteReq(&self) -> bool {
        self.initQuoteReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initQuoteReq(&mut self, v: Request_InitQuoteRequest) {
        self.initQuoteReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initQuoteReq(&mut self) -> &mut Request_InitQuoteRequest {
        if self.initQuoteReq.is_none() {
            self.initQuoteReq.set_default();
        }
        self.initQuoteReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_initQuoteReq(&mut self) -> Request_InitQuoteRequest {
        self.initQuoteReq.take().unwrap_or_else(|| Request_InitQuoteRequest::new())
    }

    // optional .aesm.message.Request.GetQuoteRequest getQuoteReq = 2;


    pub fn get_getQuoteReq(&self) -> &Request_GetQuoteRequest {
        self.getQuoteReq.as_ref().unwrap_or_else(|| <Request_GetQuoteRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getQuoteReq(&mut self) {
        self.getQuoteReq.clear();
    }

    pub fn has_getQuoteReq(&self) -> bool {
        self.getQuoteReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getQuoteReq(&mut self, v: Request_GetQuoteRequest) {
        self.getQuoteReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getQuoteReq(&mut self) -> &mut Request_GetQuoteRequest {
        if self.getQuoteReq.is_none() {
            self.getQuoteReq.set_default();
        }
        self.getQuoteReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_getQuoteReq(&mut self) -> Request_GetQuoteRequest {
        self.getQuoteReq.take().unwrap_or_else(|| Request_GetQuoteRequest::new())
    }

    // optional .aesm.message.Request.GetLaunchTokenRequest getLicTokenReq = 3;


    pub fn get_getLicTokenReq(&self) -> &Request_GetLaunchTokenRequest {
        self.getLicTokenReq.as_ref().unwrap_or_else(|| <Request_GetLaunchTokenRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getLicTokenReq(&mut self) {
        self.getLicTokenReq.clear();
    }

    pub fn has_getLicTokenReq(&self) -> bool {
        self.getLicTokenReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getLicTokenReq(&mut self, v: Request_GetLaunchTokenRequest) {
        self.getLicTokenReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getLicTokenReq(&mut self) -> &mut Request_GetLaunchTokenRequest {
        if self.getLicTokenReq.is_none() {
            self.getLicTokenReq.set_default();
        }
        self.getLicTokenReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_getLicTokenReq(&mut self) -> Request_GetLaunchTokenRequest {
        self.getLicTokenReq.take().unwrap_or_else(|| Request_GetLaunchTokenRequest::new())
    }

    // optional .aesm.message.Request.ReportAttestationErrorRequest reportErrReq = 4;


    pub fn get_reportErrReq(&self) -> &Request_ReportAttestationErrorRequest {
        self.reportErrReq.as_ref().unwrap_or_else(|| <Request_ReportAttestationErrorRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reportErrReq(&mut self) {
        self.reportErrReq.clear();
    }

    pub fn has_reportErrReq(&self) -> bool {
        self.reportErrReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reportErrReq(&mut self, v: Request_ReportAttestationErrorRequest) {
        self.reportErrReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reportErrReq(&mut self) -> &mut Request_ReportAttestationErrorRequest {
        if self.reportErrReq.is_none() {
            self.reportErrReq.set_default();
        }
        self.reportErrReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_reportErrReq(&mut self) -> Request_ReportAttestationErrorRequest {
        self.reportErrReq.take().unwrap_or_else(|| Request_ReportAttestationErrorRequest::new())
    }

    // optional .aesm.message.Request.GetWhiteListSizeRequest getWhiteListSizeReq = 10;


    pub fn get_getWhiteListSizeReq(&self) -> &Request_GetWhiteListSizeRequest {
        self.getWhiteListSizeReq.as_ref().unwrap_or_else(|| <Request_GetWhiteListSizeRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getWhiteListSizeReq(&mut self) {
        self.getWhiteListSizeReq.clear();
    }

    pub fn has_getWhiteListSizeReq(&self) -> bool {
        self.getWhiteListSizeReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getWhiteListSizeReq(&mut self, v: Request_GetWhiteListSizeRequest) {
        self.getWhiteListSizeReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getWhiteListSizeReq(&mut self) -> &mut Request_GetWhiteListSizeRequest {
        if self.getWhiteListSizeReq.is_none() {
            self.getWhiteListSizeReq.set_default();
        }
        self.getWhiteListSizeReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_getWhiteListSizeReq(&mut self) -> Request_GetWhiteListSizeRequest {
        self.getWhiteListSizeReq.take().unwrap_or_else(|| Request_GetWhiteListSizeRequest::new())
    }

    // optional .aesm.message.Request.GetWhiteListRequest getWhiteListReq = 11;


    pub fn get_getWhiteListReq(&self) -> &Request_GetWhiteListRequest {
        self.getWhiteListReq.as_ref().unwrap_or_else(|| <Request_GetWhiteListRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getWhiteListReq(&mut self) {
        self.getWhiteListReq.clear();
    }

    pub fn has_getWhiteListReq(&self) -> bool {
        self.getWhiteListReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getWhiteListReq(&mut self, v: Request_GetWhiteListRequest) {
        self.getWhiteListReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getWhiteListReq(&mut self) -> &mut Request_GetWhiteListRequest {
        if self.getWhiteListReq.is_none() {
            self.getWhiteListReq.set_default();
        }
        self.getWhiteListReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_getWhiteListReq(&mut self) -> Request_GetWhiteListRequest {
        self.getWhiteListReq.take().unwrap_or_else(|| Request_GetWhiteListRequest::new())
    }

    // optional .aesm.message.Request.SGXGetExtendedEpidGroupIdRequest sgxGetExtendedEpidGroupIdReq = 12;


    pub fn get_sgxGetExtendedEpidGroupIdReq(&self) -> &Request_SGXGetExtendedEpidGroupIdRequest {
        self.sgxGetExtendedEpidGroupIdReq.as_ref().unwrap_or_else(|| <Request_SGXGetExtendedEpidGroupIdRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sgxGetExtendedEpidGroupIdReq(&mut self) {
        self.sgxGetExtendedEpidGroupIdReq.clear();
    }

    pub fn has_sgxGetExtendedEpidGroupIdReq(&self) -> bool {
        self.sgxGetExtendedEpidGroupIdReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sgxGetExtendedEpidGroupIdReq(&mut self, v: Request_SGXGetExtendedEpidGroupIdRequest) {
        self.sgxGetExtendedEpidGroupIdReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sgxGetExtendedEpidGroupIdReq(&mut self) -> &mut Request_SGXGetExtendedEpidGroupIdRequest {
        if self.sgxGetExtendedEpidGroupIdReq.is_none() {
            self.sgxGetExtendedEpidGroupIdReq.set_default();
        }
        self.sgxGetExtendedEpidGroupIdReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_sgxGetExtendedEpidGroupIdReq(&mut self) -> Request_SGXGetExtendedEpidGroupIdRequest {
        self.sgxGetExtendedEpidGroupIdReq.take().unwrap_or_else(|| Request_SGXGetExtendedEpidGroupIdRequest::new())
    }

    // optional .aesm.message.Request.SGXSwitchExtendedEpidGroupRequest sgxSwitchExtendedEpidGroupReq = 13;


    pub fn get_sgxSwitchExtendedEpidGroupReq(&self) -> &Request_SGXSwitchExtendedEpidGroupRequest {
        self.sgxSwitchExtendedEpidGroupReq.as_ref().unwrap_or_else(|| <Request_SGXSwitchExtendedEpidGroupRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sgxSwitchExtendedEpidGroupReq(&mut self) {
        self.sgxSwitchExtendedEpidGroupReq.clear();
    }

    pub fn has_sgxSwitchExtendedEpidGroupReq(&self) -> bool {
        self.sgxSwitchExtendedEpidGroupReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sgxSwitchExtendedEpidGroupReq(&mut self, v: Request_SGXSwitchExtendedEpidGroupRequest) {
        self.sgxSwitchExtendedEpidGroupReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sgxSwitchExtendedEpidGroupReq(&mut self) -> &mut Request_SGXSwitchExtendedEpidGroupRequest {
        if self.sgxSwitchExtendedEpidGroupReq.is_none() {
            self.sgxSwitchExtendedEpidGroupReq.set_default();
        }
        self.sgxSwitchExtendedEpidGroupReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_sgxSwitchExtendedEpidGroupReq(&mut self) -> Request_SGXSwitchExtendedEpidGroupRequest {
        self.sgxSwitchExtendedEpidGroupReq.take().unwrap_or_else(|| Request_SGXSwitchExtendedEpidGroupRequest::new())
    }

    // optional .aesm.message.Request.SGXRegisterRequest sgxRegisterReq = 14;


    pub fn get_sgxRegisterReq(&self) -> &Request_SGXRegisterRequest {
        self.sgxRegisterReq.as_ref().unwrap_or_else(|| <Request_SGXRegisterRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sgxRegisterReq(&mut self) {
        self.sgxRegisterReq.clear();
    }

    pub fn has_sgxRegisterReq(&self) -> bool {
        self.sgxRegisterReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sgxRegisterReq(&mut self, v: Request_SGXRegisterRequest) {
        self.sgxRegisterReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sgxRegisterReq(&mut self) -> &mut Request_SGXRegisterRequest {
        if self.sgxRegisterReq.is_none() {
            self.sgxRegisterReq.set_default();
        }
        self.sgxRegisterReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_sgxRegisterReq(&mut self) -> Request_SGXRegisterRequest {
        self.sgxRegisterReq.take().unwrap_or_else(|| Request_SGXRegisterRequest::new())
    }

    // optional .aesm.message.Request.InitQuoteExRequest initQuoteExReq = 15;


    pub fn get_initQuoteExReq(&self) -> &Request_InitQuoteExRequest {
        self.initQuoteExReq.as_ref().unwrap_or_else(|| <Request_InitQuoteExRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_initQuoteExReq(&mut self) {
        self.initQuoteExReq.clear();
    }

    pub fn has_initQuoteExReq(&self) -> bool {
        self.initQuoteExReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initQuoteExReq(&mut self, v: Request_InitQuoteExRequest) {
        self.initQuoteExReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initQuoteExReq(&mut self) -> &mut Request_InitQuoteExRequest {
        if self.initQuoteExReq.is_none() {
            self.initQuoteExReq.set_default();
        }
        self.initQuoteExReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_initQuoteExReq(&mut self) -> Request_InitQuoteExRequest {
        self.initQuoteExReq.take().unwrap_or_else(|| Request_InitQuoteExRequest::new())
    }

    // optional .aesm.message.Request.GetQuoteSizeExRequest getQuoteSizeExReq = 16;


    pub fn get_getQuoteSizeExReq(&self) -> &Request_GetQuoteSizeExRequest {
        self.getQuoteSizeExReq.as_ref().unwrap_or_else(|| <Request_GetQuoteSizeExRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getQuoteSizeExReq(&mut self) {
        self.getQuoteSizeExReq.clear();
    }

    pub fn has_getQuoteSizeExReq(&self) -> bool {
        self.getQuoteSizeExReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getQuoteSizeExReq(&mut self, v: Request_GetQuoteSizeExRequest) {
        self.getQuoteSizeExReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getQuoteSizeExReq(&mut self) -> &mut Request_GetQuoteSizeExRequest {
        if self.getQuoteSizeExReq.is_none() {
            self.getQuoteSizeExReq.set_default();
        }
        self.getQuoteSizeExReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_getQuoteSizeExReq(&mut self) -> Request_GetQuoteSizeExRequest {
        self.getQuoteSizeExReq.take().unwrap_or_else(|| Request_GetQuoteSizeExRequest::new())
    }

    // optional .aesm.message.Request.GetQuoteExRequest getQuoteExReq = 17;


    pub fn get_getQuoteExReq(&self) -> &Request_GetQuoteExRequest {
        self.getQuoteExReq.as_ref().unwrap_or_else(|| <Request_GetQuoteExRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getQuoteExReq(&mut self) {
        self.getQuoteExReq.clear();
    }

    pub fn has_getQuoteExReq(&self) -> bool {
        self.getQuoteExReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getQuoteExReq(&mut self, v: Request_GetQuoteExRequest) {
        self.getQuoteExReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getQuoteExReq(&mut self) -> &mut Request_GetQuoteExRequest {
        if self.getQuoteExReq.is_none() {
            self.getQuoteExReq.set_default();
        }
        self.getQuoteExReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_getQuoteExReq(&mut self) -> Request_GetQuoteExRequest {
        self.getQuoteExReq.take().unwrap_or_else(|| Request_GetQuoteExRequest::new())
    }

    // optional .aesm.message.Request.CheckUpdateStatusRequest checkUpdateStatusReq = 18;


    pub fn get_checkUpdateStatusReq(&self) -> &Request_CheckUpdateStatusRequest {
        self.checkUpdateStatusReq.as_ref().unwrap_or_else(|| <Request_CheckUpdateStatusRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_checkUpdateStatusReq(&mut self) {
        self.checkUpdateStatusReq.clear();
    }

    pub fn has_checkUpdateStatusReq(&self) -> bool {
        self.checkUpdateStatusReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkUpdateStatusReq(&mut self, v: Request_CheckUpdateStatusRequest) {
        self.checkUpdateStatusReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checkUpdateStatusReq(&mut self) -> &mut Request_CheckUpdateStatusRequest {
        if self.checkUpdateStatusReq.is_none() {
            self.checkUpdateStatusReq.set_default();
        }
        self.checkUpdateStatusReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_checkUpdateStatusReq(&mut self) -> Request_CheckUpdateStatusRequest {
        self.checkUpdateStatusReq.take().unwrap_or_else(|| Request_CheckUpdateStatusRequest::new())
    }

    // optional .aesm.message.Request.SelectAttKeyIDRequest selectAttKeyIDReq = 19;


    pub fn get_selectAttKeyIDReq(&self) -> &Request_SelectAttKeyIDRequest {
        self.selectAttKeyIDReq.as_ref().unwrap_or_else(|| <Request_SelectAttKeyIDRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_selectAttKeyIDReq(&mut self) {
        self.selectAttKeyIDReq.clear();
    }

    pub fn has_selectAttKeyIDReq(&self) -> bool {
        self.selectAttKeyIDReq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectAttKeyIDReq(&mut self, v: Request_SelectAttKeyIDRequest) {
        self.selectAttKeyIDReq = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selectAttKeyIDReq(&mut self) -> &mut Request_SelectAttKeyIDRequest {
        if self.selectAttKeyIDReq.is_none() {
            self.selectAttKeyIDReq.set_default();
        }
        self.selectAttKeyIDReq.as_mut().unwrap()
    }

    // Take field
    pub fn take_selectAttKeyIDReq(&mut self) -> Request_SelectAttKeyIDRequest {
        self.selectAttKeyIDReq.take().unwrap_or_else(|| Request_SelectAttKeyIDRequest::new())
    }
}

impl ::protobuf::Message for Request {
    fn is_initialized(&self) -> bool {
        for v in &self.initQuoteReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getQuoteReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getLicTokenReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reportErrReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getWhiteListSizeReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getWhiteListReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sgxGetExtendedEpidGroupIdReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sgxSwitchExtendedEpidGroupReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sgxRegisterReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initQuoteExReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getQuoteSizeExReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getQuoteExReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkUpdateStatusReq {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selectAttKeyIDReq {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.initQuoteReq)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getQuoteReq)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getLicTokenReq)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reportErrReq)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getWhiteListSizeReq)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getWhiteListReq)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sgxGetExtendedEpidGroupIdReq)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sgxSwitchExtendedEpidGroupReq)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sgxRegisterReq)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.initQuoteExReq)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getQuoteSizeExReq)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getQuoteExReq)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkUpdateStatusReq)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selectAttKeyIDReq)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.initQuoteReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getQuoteReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getLicTokenReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reportErrReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getWhiteListSizeReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getWhiteListReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sgxGetExtendedEpidGroupIdReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sgxSwitchExtendedEpidGroupReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sgxRegisterReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.initQuoteExReq.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getQuoteSizeExReq.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getQuoteExReq.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkUpdateStatusReq.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.selectAttKeyIDReq.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.initQuoteReq.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getQuoteReq.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getLicTokenReq.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reportErrReq.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getWhiteListSizeReq.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getWhiteListReq.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sgxGetExtendedEpidGroupIdReq.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sgxSwitchExtendedEpidGroupReq.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sgxRegisterReq.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.initQuoteExReq.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getQuoteSizeExReq.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getQuoteExReq.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkUpdateStatusReq.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.selectAttKeyIDReq.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request {
        Request::new()
    }

    fn default_instance() -> &'static Request {
        static instance: ::protobuf::rt::LazyV2<Request> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request::new)
    }
}

impl ::protobuf::Clear for Request {
    fn clear(&mut self) {
        self.initQuoteReq.clear();
        self.getQuoteReq.clear();
        self.getLicTokenReq.clear();
        self.reportErrReq.clear();
        self.getWhiteListSizeReq.clear();
        self.getWhiteListReq.clear();
        self.sgxGetExtendedEpidGroupIdReq.clear();
        self.sgxSwitchExtendedEpidGroupReq.clear();
        self.sgxRegisterReq.clear();
        self.initQuoteExReq.clear();
        self.getQuoteSizeExReq.clear();
        self.getQuoteExReq.clear();
        self.checkUpdateStatusReq.clear();
        self.selectAttKeyIDReq.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Request {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request_InitQuoteRequest {
    // message fields
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_InitQuoteRequest {
    fn default() -> &'a Request_InitQuoteRequest {
        <Request_InitQuoteRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_InitQuoteRequest {
    pub fn new() -> Request_InitQuoteRequest {
        ::std::default::Default::default()
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_InitQuoteRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_InitQuoteRequest {
        Request_InitQuoteRequest::new()
    }

    fn default_instance() -> &'static Request_InitQuoteRequest {
        static instance: ::protobuf::rt::LazyV2<Request_InitQuoteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_InitQuoteRequest::new)
    }
}

impl ::protobuf::Clear for Request_InitQuoteRequest {
    fn clear(&mut self) {
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_InitQuoteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request_GetQuoteRequest {
    // message fields
    report: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    quote_type: ::std::option::Option<u32>,
    spid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    nonce: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    sig_rl: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    buf_size: ::std::option::Option<u32>,
    qe_report: ::std::option::Option<bool>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_GetQuoteRequest {
    fn default() -> &'a Request_GetQuoteRequest {
        <Request_GetQuoteRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_GetQuoteRequest {
    pub fn new() -> Request_GetQuoteRequest {
        ::std::default::Default::default()
    }

    // required bytes report = 1;


    pub fn get_report(&self) -> &[u8] {
        match self.report.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_report(&mut self) {
        self.report.clear();
    }

    pub fn has_report(&self) -> bool {
        self.report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report(&mut self, v: ::std::vec::Vec<u8>) {
        self.report = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_report(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.report.is_none() {
            self.report.set_default();
        }
        self.report.as_mut().unwrap()
    }

    // Take field
    pub fn take_report(&mut self) -> ::std::vec::Vec<u8> {
        self.report.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 quote_type = 2;


    pub fn get_quote_type(&self) -> u32 {
        self.quote_type.unwrap_or(0)
    }
    pub fn clear_quote_type(&mut self) {
        self.quote_type = ::std::option::Option::None;
    }

    pub fn has_quote_type(&self) -> bool {
        self.quote_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote_type(&mut self, v: u32) {
        self.quote_type = ::std::option::Option::Some(v);
    }

    // required bytes spid = 3;


    pub fn get_spid(&self) -> &[u8] {
        match self.spid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_spid(&mut self) {
        self.spid.clear();
    }

    pub fn has_spid(&self) -> bool {
        self.spid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spid(&mut self, v: ::std::vec::Vec<u8>) {
        self.spid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.spid.is_none() {
            self.spid.set_default();
        }
        self.spid.as_mut().unwrap()
    }

    // Take field
    pub fn take_spid(&mut self) -> ::std::vec::Vec<u8> {
        self.spid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes nonce = 4;


    pub fn get_nonce(&self) -> &[u8] {
        match self.nonce.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    pub fn has_nonce(&self) -> bool {
        self.nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.nonce.is_none() {
            self.nonce.set_default();
        }
        self.nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        self.nonce.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes sig_rl = 5;


    pub fn get_sig_rl(&self) -> &[u8] {
        match self.sig_rl.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_sig_rl(&mut self) {
        self.sig_rl.clear();
    }

    pub fn has_sig_rl(&self) -> bool {
        self.sig_rl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sig_rl(&mut self, v: ::std::vec::Vec<u8>) {
        self.sig_rl = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sig_rl(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.sig_rl.is_none() {
            self.sig_rl.set_default();
        }
        self.sig_rl.as_mut().unwrap()
    }

    // Take field
    pub fn take_sig_rl(&mut self) -> ::std::vec::Vec<u8> {
        self.sig_rl.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 buf_size = 6;


    pub fn get_buf_size(&self) -> u32 {
        self.buf_size.unwrap_or(0)
    }
    pub fn clear_buf_size(&mut self) {
        self.buf_size = ::std::option::Option::None;
    }

    pub fn has_buf_size(&self) -> bool {
        self.buf_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buf_size(&mut self, v: u32) {
        self.buf_size = ::std::option::Option::Some(v);
    }

    // optional bool qe_report = 7;


    pub fn get_qe_report(&self) -> bool {
        self.qe_report.unwrap_or(false)
    }
    pub fn clear_qe_report(&mut self) {
        self.qe_report = ::std::option::Option::None;
    }

    pub fn has_qe_report(&self) -> bool {
        self.qe_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qe_report(&mut self, v: bool) {
        self.qe_report = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_GetQuoteRequest {
    fn is_initialized(&self) -> bool {
        if self.report.is_none() {
            return false;
        }
        if self.quote_type.is_none() {
            return false;
        }
        if self.spid.is_none() {
            return false;
        }
        if self.buf_size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.report)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quote_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.spid)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sig_rl)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.buf_size = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.qe_report = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.report.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.quote_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.spid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(ref v) = self.nonce.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.sig_rl.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.buf_size {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.qe_report {
            my_size += 2;
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.report.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.quote_type {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.spid.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(ref v) = self.nonce.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.sig_rl.as_ref() {
            os.write_bytes(5, &v)?;
        }
        if let Some(v) = self.buf_size {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.qe_report {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_GetQuoteRequest {
        Request_GetQuoteRequest::new()
    }

    fn default_instance() -> &'static Request_GetQuoteRequest {
        static instance: ::protobuf::rt::LazyV2<Request_GetQuoteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_GetQuoteRequest::new)
    }
}

impl ::protobuf::Clear for Request_GetQuoteRequest {
    fn clear(&mut self) {
        self.report.clear();
        self.quote_type = ::std::option::Option::None;
        self.spid.clear();
        self.nonce.clear();
        self.sig_rl.clear();
        self.buf_size = ::std::option::Option::None;
        self.qe_report = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_GetQuoteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request_GetLaunchTokenRequest {
    // message fields
    mr_enclave: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    mr_signer: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    se_attributes: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_GetLaunchTokenRequest {
    fn default() -> &'a Request_GetLaunchTokenRequest {
        <Request_GetLaunchTokenRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_GetLaunchTokenRequest {
    pub fn new() -> Request_GetLaunchTokenRequest {
        ::std::default::Default::default()
    }

    // required bytes mr_enclave = 1;


    pub fn get_mr_enclave(&self) -> &[u8] {
        match self.mr_enclave.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_mr_enclave(&mut self) {
        self.mr_enclave.clear();
    }

    pub fn has_mr_enclave(&self) -> bool {
        self.mr_enclave.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mr_enclave(&mut self, v: ::std::vec::Vec<u8>) {
        self.mr_enclave = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mr_enclave(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mr_enclave.is_none() {
            self.mr_enclave.set_default();
        }
        self.mr_enclave.as_mut().unwrap()
    }

    // Take field
    pub fn take_mr_enclave(&mut self) -> ::std::vec::Vec<u8> {
        self.mr_enclave.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes mr_signer = 2;


    pub fn get_mr_signer(&self) -> &[u8] {
        match self.mr_signer.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_mr_signer(&mut self) {
        self.mr_signer.clear();
    }

    pub fn has_mr_signer(&self) -> bool {
        self.mr_signer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mr_signer(&mut self, v: ::std::vec::Vec<u8>) {
        self.mr_signer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mr_signer(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.mr_signer.is_none() {
            self.mr_signer.set_default();
        }
        self.mr_signer.as_mut().unwrap()
    }

    // Take field
    pub fn take_mr_signer(&mut self) -> ::std::vec::Vec<u8> {
        self.mr_signer.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bytes se_attributes = 3;


    pub fn get_se_attributes(&self) -> &[u8] {
        match self.se_attributes.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_se_attributes(&mut self) {
        self.se_attributes.clear();
    }

    pub fn has_se_attributes(&self) -> bool {
        self.se_attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_se_attributes(&mut self, v: ::std::vec::Vec<u8>) {
        self.se_attributes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_se_attributes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.se_attributes.is_none() {
            self.se_attributes.set_default();
        }
        self.se_attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_se_attributes(&mut self) -> ::std::vec::Vec<u8> {
        self.se_attributes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_GetLaunchTokenRequest {
    fn is_initialized(&self) -> bool {
        if self.mr_enclave.is_none() {
            return false;
        }
        if self.mr_signer.is_none() {
            return false;
        }
        if self.se_attributes.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.mr_enclave)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.mr_signer)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.se_attributes)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mr_enclave.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.mr_signer.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.se_attributes.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mr_enclave.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.mr_signer.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.se_attributes.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_GetLaunchTokenRequest {
        Request_GetLaunchTokenRequest::new()
    }

    fn default_instance() -> &'static Request_GetLaunchTokenRequest {
        static instance: ::protobuf::rt::LazyV2<Request_GetLaunchTokenRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_GetLaunchTokenRequest::new)
    }
}

impl ::protobuf::Clear for Request_GetLaunchTokenRequest {
    fn clear(&mut self) {
        self.mr_enclave.clear();
        self.mr_signer.clear();
        self.se_attributes.clear();
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_GetLaunchTokenRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request_ReportAttestationErrorRequest {
    // message fields
    platform_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    attestation_error_code: ::std::option::Option<u32>,
    update_info_size: ::std::option::Option<u32>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_ReportAttestationErrorRequest {
    fn default() -> &'a Request_ReportAttestationErrorRequest {
        <Request_ReportAttestationErrorRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_ReportAttestationErrorRequest {
    pub fn new() -> Request_ReportAttestationErrorRequest {
        ::std::default::Default::default()
    }

    // required bytes platform_info = 1;


    pub fn get_platform_info(&self) -> &[u8] {
        match self.platform_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_platform_info(&mut self) {
        self.platform_info.clear();
    }

    pub fn has_platform_info(&self) -> bool {
        self.platform_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.platform_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_platform_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.platform_info.is_none() {
            self.platform_info.set_default();
        }
        self.platform_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_platform_info(&mut self) -> ::std::vec::Vec<u8> {
        self.platform_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 attestation_error_code = 2;


    pub fn get_attestation_error_code(&self) -> u32 {
        self.attestation_error_code.unwrap_or(0)
    }
    pub fn clear_attestation_error_code(&mut self) {
        self.attestation_error_code = ::std::option::Option::None;
    }

    pub fn has_attestation_error_code(&self) -> bool {
        self.attestation_error_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attestation_error_code(&mut self, v: u32) {
        self.attestation_error_code = ::std::option::Option::Some(v);
    }

    // required uint32 update_info_size = 3;


    pub fn get_update_info_size(&self) -> u32 {
        self.update_info_size.unwrap_or(0)
    }
    pub fn clear_update_info_size(&mut self) {
        self.update_info_size = ::std::option::Option::None;
    }

    pub fn has_update_info_size(&self) -> bool {
        self.update_info_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_info_size(&mut self, v: u32) {
        self.update_info_size = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_ReportAttestationErrorRequest {
    fn is_initialized(&self) -> bool {
        if self.platform_info.is_none() {
            return false;
        }
        if self.attestation_error_code.is_none() {
            return false;
        }
        if self.update_info_size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.platform_info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.attestation_error_code = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.update_info_size = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.platform_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.attestation_error_code {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.update_info_size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.platform_info.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.attestation_error_code {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.update_info_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_ReportAttestationErrorRequest {
        Request_ReportAttestationErrorRequest::new()
    }

    fn default_instance() -> &'static Request_ReportAttestationErrorRequest {
        static instance: ::protobuf::rt::LazyV2<Request_ReportAttestationErrorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_ReportAttestationErrorRequest::new)
    }
}

impl ::protobuf::Clear for Request_ReportAttestationErrorRequest {
    fn clear(&mut self) {
        self.platform_info.clear();
        self.attestation_error_code = ::std::option::Option::None;
        self.update_info_size = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_ReportAttestationErrorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request_CheckUpdateStatusRequest {
    // message fields
    platform_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    update_info_size: ::std::option::Option<u32>,
    config: ::std::option::Option<u32>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_CheckUpdateStatusRequest {
    fn default() -> &'a Request_CheckUpdateStatusRequest {
        <Request_CheckUpdateStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_CheckUpdateStatusRequest {
    pub fn new() -> Request_CheckUpdateStatusRequest {
        ::std::default::Default::default()
    }

    // optional bytes platform_info = 1;


    pub fn get_platform_info(&self) -> &[u8] {
        match self.platform_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_platform_info(&mut self) {
        self.platform_info.clear();
    }

    pub fn has_platform_info(&self) -> bool {
        self.platform_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.platform_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_platform_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.platform_info.is_none() {
            self.platform_info.set_default();
        }
        self.platform_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_platform_info(&mut self) -> ::std::vec::Vec<u8> {
        self.platform_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 update_info_size = 2;


    pub fn get_update_info_size(&self) -> u32 {
        self.update_info_size.unwrap_or(0)
    }
    pub fn clear_update_info_size(&mut self) {
        self.update_info_size = ::std::option::Option::None;
    }

    pub fn has_update_info_size(&self) -> bool {
        self.update_info_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_info_size(&mut self, v: u32) {
        self.update_info_size = ::std::option::Option::Some(v);
    }

    // required uint32 config = 3;


    pub fn get_config(&self) -> u32 {
        self.config.unwrap_or(0)
    }
    pub fn clear_config(&mut self) {
        self.config = ::std::option::Option::None;
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: u32) {
        self.config = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_CheckUpdateStatusRequest {
    fn is_initialized(&self) -> bool {
        if self.update_info_size.is_none() {
            return false;
        }
        if self.config.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.platform_info)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.update_info_size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.config = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.platform_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.update_info_size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.config {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.platform_info.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.update_info_size {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.config {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_CheckUpdateStatusRequest {
        Request_CheckUpdateStatusRequest::new()
    }

    fn default_instance() -> &'static Request_CheckUpdateStatusRequest {
        static instance: ::protobuf::rt::LazyV2<Request_CheckUpdateStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_CheckUpdateStatusRequest::new)
    }
}

impl ::protobuf::Clear for Request_CheckUpdateStatusRequest {
    fn clear(&mut self) {
        self.platform_info.clear();
        self.update_info_size = ::std::option::Option::None;
        self.config = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_CheckUpdateStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request_GetWhiteListSizeRequest {
    // message fields
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_GetWhiteListSizeRequest {
    fn default() -> &'a Request_GetWhiteListSizeRequest {
        <Request_GetWhiteListSizeRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_GetWhiteListSizeRequest {
    pub fn new() -> Request_GetWhiteListSizeRequest {
        ::std::default::Default::default()
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_GetWhiteListSizeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_GetWhiteListSizeRequest {
        Request_GetWhiteListSizeRequest::new()
    }

    fn default_instance() -> &'static Request_GetWhiteListSizeRequest {
        static instance: ::protobuf::rt::LazyV2<Request_GetWhiteListSizeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_GetWhiteListSizeRequest::new)
    }
}

impl ::protobuf::Clear for Request_GetWhiteListSizeRequest {
    fn clear(&mut self) {
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_GetWhiteListSizeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request_GetWhiteListRequest {
    // message fields
    white_list_size: ::std::option::Option<u32>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_GetWhiteListRequest {
    fn default() -> &'a Request_GetWhiteListRequest {
        <Request_GetWhiteListRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_GetWhiteListRequest {
    pub fn new() -> Request_GetWhiteListRequest {
        ::std::default::Default::default()
    }

    // optional uint32 white_list_size = 1;


    pub fn get_white_list_size(&self) -> u32 {
        self.white_list_size.unwrap_or(0)
    }
    pub fn clear_white_list_size(&mut self) {
        self.white_list_size = ::std::option::Option::None;
    }

    pub fn has_white_list_size(&self) -> bool {
        self.white_list_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_white_list_size(&mut self, v: u32) {
        self.white_list_size = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_GetWhiteListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.white_list_size = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.white_list_size {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.white_list_size {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_GetWhiteListRequest {
        Request_GetWhiteListRequest::new()
    }

    fn default_instance() -> &'static Request_GetWhiteListRequest {
        static instance: ::protobuf::rt::LazyV2<Request_GetWhiteListRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_GetWhiteListRequest::new)
    }
}

impl ::protobuf::Clear for Request_GetWhiteListRequest {
    fn clear(&mut self) {
        self.white_list_size = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_GetWhiteListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request_SGXGetExtendedEpidGroupIdRequest {
    // message fields
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_SGXGetExtendedEpidGroupIdRequest {
    fn default() -> &'a Request_SGXGetExtendedEpidGroupIdRequest {
        <Request_SGXGetExtendedEpidGroupIdRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_SGXGetExtendedEpidGroupIdRequest {
    pub fn new() -> Request_SGXGetExtendedEpidGroupIdRequest {
        ::std::default::Default::default()
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_SGXGetExtendedEpidGroupIdRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_SGXGetExtendedEpidGroupIdRequest {
        Request_SGXGetExtendedEpidGroupIdRequest::new()
    }

    fn default_instance() -> &'static Request_SGXGetExtendedEpidGroupIdRequest {
        static instance: ::protobuf::rt::LazyV2<Request_SGXGetExtendedEpidGroupIdRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_SGXGetExtendedEpidGroupIdRequest::new)
    }
}

impl ::protobuf::Clear for Request_SGXGetExtendedEpidGroupIdRequest {
    fn clear(&mut self) {
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_SGXGetExtendedEpidGroupIdRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request_SGXSwitchExtendedEpidGroupRequest {
    // message fields
    x_group_id: ::std::option::Option<u32>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_SGXSwitchExtendedEpidGroupRequest {
    fn default() -> &'a Request_SGXSwitchExtendedEpidGroupRequest {
        <Request_SGXSwitchExtendedEpidGroupRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_SGXSwitchExtendedEpidGroupRequest {
    pub fn new() -> Request_SGXSwitchExtendedEpidGroupRequest {
        ::std::default::Default::default()
    }

    // optional uint32 x_group_id = 1;


    pub fn get_x_group_id(&self) -> u32 {
        self.x_group_id.unwrap_or(0)
    }
    pub fn clear_x_group_id(&mut self) {
        self.x_group_id = ::std::option::Option::None;
    }

    pub fn has_x_group_id(&self) -> bool {
        self.x_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_group_id(&mut self, v: u32) {
        self.x_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_SGXSwitchExtendedEpidGroupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.x_group_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.x_group_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.x_group_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_SGXSwitchExtendedEpidGroupRequest {
        Request_SGXSwitchExtendedEpidGroupRequest::new()
    }

    fn default_instance() -> &'static Request_SGXSwitchExtendedEpidGroupRequest {
        static instance: ::protobuf::rt::LazyV2<Request_SGXSwitchExtendedEpidGroupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_SGXSwitchExtendedEpidGroupRequest::new)
    }
}

impl ::protobuf::Clear for Request_SGXSwitchExtendedEpidGroupRequest {
    fn clear(&mut self) {
        self.x_group_id = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_SGXSwitchExtendedEpidGroupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request_SGXRegisterRequest {
    // message fields
    buf: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    data_type: ::std::option::Option<u32>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_SGXRegisterRequest {
    fn default() -> &'a Request_SGXRegisterRequest {
        <Request_SGXRegisterRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_SGXRegisterRequest {
    pub fn new() -> Request_SGXRegisterRequest {
        ::std::default::Default::default()
    }

    // required bytes buf = 1;


    pub fn get_buf(&self) -> &[u8] {
        match self.buf.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_buf(&mut self) {
        self.buf.clear();
    }

    pub fn has_buf(&self) -> bool {
        self.buf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buf(&mut self, v: ::std::vec::Vec<u8>) {
        self.buf = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buf(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.buf.is_none() {
            self.buf.set_default();
        }
        self.buf.as_mut().unwrap()
    }

    // Take field
    pub fn take_buf(&mut self) -> ::std::vec::Vec<u8> {
        self.buf.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 data_type = 2;


    pub fn get_data_type(&self) -> u32 {
        self.data_type.unwrap_or(0)
    }
    pub fn clear_data_type(&mut self) {
        self.data_type = ::std::option::Option::None;
    }

    pub fn has_data_type(&self) -> bool {
        self.data_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: u32) {
        self.data_type = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_SGXRegisterRequest {
    fn is_initialized(&self) -> bool {
        if self.buf.is_none() {
            return false;
        }
        if self.data_type.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.buf)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.data_type = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.buf.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.data_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.buf.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.data_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_SGXRegisterRequest {
        Request_SGXRegisterRequest::new()
    }

    fn default_instance() -> &'static Request_SGXRegisterRequest {
        static instance: ::protobuf::rt::LazyV2<Request_SGXRegisterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_SGXRegisterRequest::new)
    }
}

impl ::protobuf::Clear for Request_SGXRegisterRequest {
    fn clear(&mut self) {
        self.buf.clear();
        self.data_type = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_SGXRegisterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request_InitQuoteExRequest {
    // message fields
    att_key_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    b_pub_key_id: ::std::option::Option<bool>,
    buf_size: ::std::option::Option<u64>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_InitQuoteExRequest {
    fn default() -> &'a Request_InitQuoteExRequest {
        <Request_InitQuoteExRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_InitQuoteExRequest {
    pub fn new() -> Request_InitQuoteExRequest {
        ::std::default::Default::default()
    }

    // optional bytes att_key_id = 1;


    pub fn get_att_key_id(&self) -> &[u8] {
        match self.att_key_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_att_key_id(&mut self) {
        self.att_key_id.clear();
    }

    pub fn has_att_key_id(&self) -> bool {
        self.att_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_att_key_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.att_key_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_att_key_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.att_key_id.is_none() {
            self.att_key_id.set_default();
        }
        self.att_key_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_att_key_id(&mut self) -> ::std::vec::Vec<u8> {
        self.att_key_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required bool b_pub_key_id = 3;


    pub fn get_b_pub_key_id(&self) -> bool {
        self.b_pub_key_id.unwrap_or(false)
    }
    pub fn clear_b_pub_key_id(&mut self) {
        self.b_pub_key_id = ::std::option::Option::None;
    }

    pub fn has_b_pub_key_id(&self) -> bool {
        self.b_pub_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b_pub_key_id(&mut self, v: bool) {
        self.b_pub_key_id = ::std::option::Option::Some(v);
    }

    // optional uint64 buf_size = 4;


    pub fn get_buf_size(&self) -> u64 {
        self.buf_size.unwrap_or(0)
    }
    pub fn clear_buf_size(&mut self) {
        self.buf_size = ::std::option::Option::None;
    }

    pub fn has_buf_size(&self) -> bool {
        self.buf_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buf_size(&mut self, v: u64) {
        self.buf_size = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_InitQuoteExRequest {
    fn is_initialized(&self) -> bool {
        if self.b_pub_key_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.att_key_id)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.b_pub_key_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.buf_size = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.att_key_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.b_pub_key_id {
            my_size += 2;
        }
        if let Some(v) = self.buf_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.att_key_id.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.b_pub_key_id {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.buf_size {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_InitQuoteExRequest {
        Request_InitQuoteExRequest::new()
    }

    fn default_instance() -> &'static Request_InitQuoteExRequest {
        static instance: ::protobuf::rt::LazyV2<Request_InitQuoteExRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_InitQuoteExRequest::new)
    }
}

impl ::protobuf::Clear for Request_InitQuoteExRequest {
    fn clear(&mut self) {
        self.att_key_id.clear();
        self.b_pub_key_id = ::std::option::Option::None;
        self.buf_size = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_InitQuoteExRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request_SelectAttKeyIDRequest {
    // message fields
    att_key_id_list: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_SelectAttKeyIDRequest {
    fn default() -> &'a Request_SelectAttKeyIDRequest {
        <Request_SelectAttKeyIDRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_SelectAttKeyIDRequest {
    pub fn new() -> Request_SelectAttKeyIDRequest {
        ::std::default::Default::default()
    }

    // optional bytes att_key_id_list = 1;


    pub fn get_att_key_id_list(&self) -> &[u8] {
        match self.att_key_id_list.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_att_key_id_list(&mut self) {
        self.att_key_id_list.clear();
    }

    pub fn has_att_key_id_list(&self) -> bool {
        self.att_key_id_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_att_key_id_list(&mut self, v: ::std::vec::Vec<u8>) {
        self.att_key_id_list = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_att_key_id_list(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.att_key_id_list.is_none() {
            self.att_key_id_list.set_default();
        }
        self.att_key_id_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_att_key_id_list(&mut self) -> ::std::vec::Vec<u8> {
        self.att_key_id_list.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 timeout = 2;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_SelectAttKeyIDRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.att_key_id_list)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.att_key_id_list.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.att_key_id_list.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_SelectAttKeyIDRequest {
        Request_SelectAttKeyIDRequest::new()
    }

    fn default_instance() -> &'static Request_SelectAttKeyIDRequest {
        static instance: ::protobuf::rt::LazyV2<Request_SelectAttKeyIDRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_SelectAttKeyIDRequest::new)
    }
}

impl ::protobuf::Clear for Request_SelectAttKeyIDRequest {
    fn clear(&mut self) {
        self.att_key_id_list.clear();
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_SelectAttKeyIDRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request_GetQuoteSizeExRequest {
    // message fields
    att_key_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_GetQuoteSizeExRequest {
    fn default() -> &'a Request_GetQuoteSizeExRequest {
        <Request_GetQuoteSizeExRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_GetQuoteSizeExRequest {
    pub fn new() -> Request_GetQuoteSizeExRequest {
        ::std::default::Default::default()
    }

    // optional bytes att_key_id = 1;


    pub fn get_att_key_id(&self) -> &[u8] {
        match self.att_key_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_att_key_id(&mut self) {
        self.att_key_id.clear();
    }

    pub fn has_att_key_id(&self) -> bool {
        self.att_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_att_key_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.att_key_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_att_key_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.att_key_id.is_none() {
            self.att_key_id.set_default();
        }
        self.att_key_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_att_key_id(&mut self) -> ::std::vec::Vec<u8> {
        self.att_key_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_GetQuoteSizeExRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.att_key_id)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.att_key_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.att_key_id.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_GetQuoteSizeExRequest {
        Request_GetQuoteSizeExRequest::new()
    }

    fn default_instance() -> &'static Request_GetQuoteSizeExRequest {
        static instance: ::protobuf::rt::LazyV2<Request_GetQuoteSizeExRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_GetQuoteSizeExRequest::new)
    }
}

impl ::protobuf::Clear for Request_GetQuoteSizeExRequest {
    fn clear(&mut self) {
        self.att_key_id.clear();
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_GetQuoteSizeExRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Request_GetQuoteExRequest {
    // message fields
    report: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    att_key_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    qe_report_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    buf_size: ::std::option::Option<u32>,
    timeout: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Request_GetQuoteExRequest {
    fn default() -> &'a Request_GetQuoteExRequest {
        <Request_GetQuoteExRequest as ::protobuf::Message>::default_instance()
    }
}

impl Request_GetQuoteExRequest {
    pub fn new() -> Request_GetQuoteExRequest {
        ::std::default::Default::default()
    }

    // required bytes report = 1;


    pub fn get_report(&self) -> &[u8] {
        match self.report.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_report(&mut self) {
        self.report.clear();
    }

    pub fn has_report(&self) -> bool {
        self.report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report(&mut self, v: ::std::vec::Vec<u8>) {
        self.report = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_report(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.report.is_none() {
            self.report.set_default();
        }
        self.report.as_mut().unwrap()
    }

    // Take field
    pub fn take_report(&mut self) -> ::std::vec::Vec<u8> {
        self.report.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes att_key_id = 2;


    pub fn get_att_key_id(&self) -> &[u8] {
        match self.att_key_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_att_key_id(&mut self) {
        self.att_key_id.clear();
    }

    pub fn has_att_key_id(&self) -> bool {
        self.att_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_att_key_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.att_key_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_att_key_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.att_key_id.is_none() {
            self.att_key_id.set_default();
        }
        self.att_key_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_att_key_id(&mut self) -> ::std::vec::Vec<u8> {
        self.att_key_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes qe_report_info = 3;


    pub fn get_qe_report_info(&self) -> &[u8] {
        match self.qe_report_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_qe_report_info(&mut self) {
        self.qe_report_info.clear();
    }

    pub fn has_qe_report_info(&self) -> bool {
        self.qe_report_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qe_report_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.qe_report_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_qe_report_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.qe_report_info.is_none() {
            self.qe_report_info.set_default();
        }
        self.qe_report_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_qe_report_info(&mut self) -> ::std::vec::Vec<u8> {
        self.qe_report_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // required uint32 buf_size = 4;


    pub fn get_buf_size(&self) -> u32 {
        self.buf_size.unwrap_or(0)
    }
    pub fn clear_buf_size(&mut self) {
        self.buf_size = ::std::option::Option::None;
    }

    pub fn has_buf_size(&self) -> bool {
        self.buf_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buf_size(&mut self, v: u32) {
        self.buf_size = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout = 9;


    pub fn get_timeout(&self) -> u32 {
        self.timeout.unwrap_or(0)
    }
    pub fn clear_timeout(&mut self) {
        self.timeout = ::std::option::Option::None;
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: u32) {
        self.timeout = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Request_GetQuoteExRequest {
    fn is_initialized(&self) -> bool {
        if self.report.is_none() {
            return false;
        }
        if self.buf_size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.report)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.att_key_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.qe_report_info)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.buf_size = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timeout = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.report.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(ref v) = self.att_key_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.qe_report_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.buf_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeout {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.report.as_ref() {
            os.write_bytes(1, &v)?;
        }
        if let Some(ref v) = self.att_key_id.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.qe_report_info.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.buf_size {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.timeout {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Request_GetQuoteExRequest {
        Request_GetQuoteExRequest::new()
    }

    fn default_instance() -> &'static Request_GetQuoteExRequest {
        static instance: ::protobuf::rt::LazyV2<Request_GetQuoteExRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Request_GetQuoteExRequest::new)
    }
}

impl ::protobuf::Clear for Request_GetQuoteExRequest {
    fn clear(&mut self) {
        self.report.clear();
        self.att_key_id.clear();
        self.qe_report_info.clear();
        self.buf_size = ::std::option::Option::None;
        self.timeout = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Request_GetQuoteExRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response {
    // message fields
    pub initQuoteRes: ::protobuf::SingularPtrField<Response_InitQuoteResponse>,
    pub getQuoteRes: ::protobuf::SingularPtrField<Response_GetQuoteResponse>,
    pub getLicTokenRes: ::protobuf::SingularPtrField<Response_GetLaunchTokenResponse>,
    pub reportErrRes: ::protobuf::SingularPtrField<Response_ReportAttestationErrorResponse>,
    pub getWhiteListSizeRes: ::protobuf::SingularPtrField<Response_GetWhiteListSizeResponse>,
    pub getWhiteListRes: ::protobuf::SingularPtrField<Response_GetWhiteListResponse>,
    pub sgxGetExtendedEpidGroupIdRes: ::protobuf::SingularPtrField<Response_SGXGetExtendedEpidGroupIdResponse>,
    pub sgxSwitchExtendedEpidGroupRes: ::protobuf::SingularPtrField<Response_SGXSwitchExtendedEpidGroupResponse>,
    pub sgxRegisterRes: ::protobuf::SingularPtrField<Response_SGXRegisterResponse>,
    pub initQuoteExRes: ::protobuf::SingularPtrField<Response_InitQuoteExResponse>,
    pub getQuoteSizeExRes: ::protobuf::SingularPtrField<Response_GetQuoteSizeExResponse>,
    pub getQuoteExRes: ::protobuf::SingularPtrField<Response_GetQuoteExResponse>,
    pub checkUpdateStatusRes: ::protobuf::SingularPtrField<Response_CheckUpdateStatusResponse>,
    pub selectAttKeyIDRes: ::protobuf::SingularPtrField<Response_SelectAttKeyIDResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response {
    fn default() -> &'a Response {
        <Response as ::protobuf::Message>::default_instance()
    }
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // optional .aesm.message.Response.InitQuoteResponse initQuoteRes = 1;


    pub fn get_initQuoteRes(&self) -> &Response_InitQuoteResponse {
        self.initQuoteRes.as_ref().unwrap_or_else(|| <Response_InitQuoteResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_initQuoteRes(&mut self) {
        self.initQuoteRes.clear();
    }

    pub fn has_initQuoteRes(&self) -> bool {
        self.initQuoteRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initQuoteRes(&mut self, v: Response_InitQuoteResponse) {
        self.initQuoteRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initQuoteRes(&mut self) -> &mut Response_InitQuoteResponse {
        if self.initQuoteRes.is_none() {
            self.initQuoteRes.set_default();
        }
        self.initQuoteRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_initQuoteRes(&mut self) -> Response_InitQuoteResponse {
        self.initQuoteRes.take().unwrap_or_else(|| Response_InitQuoteResponse::new())
    }

    // optional .aesm.message.Response.GetQuoteResponse getQuoteRes = 2;


    pub fn get_getQuoteRes(&self) -> &Response_GetQuoteResponse {
        self.getQuoteRes.as_ref().unwrap_or_else(|| <Response_GetQuoteResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getQuoteRes(&mut self) {
        self.getQuoteRes.clear();
    }

    pub fn has_getQuoteRes(&self) -> bool {
        self.getQuoteRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getQuoteRes(&mut self, v: Response_GetQuoteResponse) {
        self.getQuoteRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getQuoteRes(&mut self) -> &mut Response_GetQuoteResponse {
        if self.getQuoteRes.is_none() {
            self.getQuoteRes.set_default();
        }
        self.getQuoteRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_getQuoteRes(&mut self) -> Response_GetQuoteResponse {
        self.getQuoteRes.take().unwrap_or_else(|| Response_GetQuoteResponse::new())
    }

    // optional .aesm.message.Response.GetLaunchTokenResponse getLicTokenRes = 3;


    pub fn get_getLicTokenRes(&self) -> &Response_GetLaunchTokenResponse {
        self.getLicTokenRes.as_ref().unwrap_or_else(|| <Response_GetLaunchTokenResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getLicTokenRes(&mut self) {
        self.getLicTokenRes.clear();
    }

    pub fn has_getLicTokenRes(&self) -> bool {
        self.getLicTokenRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getLicTokenRes(&mut self, v: Response_GetLaunchTokenResponse) {
        self.getLicTokenRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getLicTokenRes(&mut self) -> &mut Response_GetLaunchTokenResponse {
        if self.getLicTokenRes.is_none() {
            self.getLicTokenRes.set_default();
        }
        self.getLicTokenRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_getLicTokenRes(&mut self) -> Response_GetLaunchTokenResponse {
        self.getLicTokenRes.take().unwrap_or_else(|| Response_GetLaunchTokenResponse::new())
    }

    // optional .aesm.message.Response.ReportAttestationErrorResponse reportErrRes = 4;


    pub fn get_reportErrRes(&self) -> &Response_ReportAttestationErrorResponse {
        self.reportErrRes.as_ref().unwrap_or_else(|| <Response_ReportAttestationErrorResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reportErrRes(&mut self) {
        self.reportErrRes.clear();
    }

    pub fn has_reportErrRes(&self) -> bool {
        self.reportErrRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reportErrRes(&mut self, v: Response_ReportAttestationErrorResponse) {
        self.reportErrRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reportErrRes(&mut self) -> &mut Response_ReportAttestationErrorResponse {
        if self.reportErrRes.is_none() {
            self.reportErrRes.set_default();
        }
        self.reportErrRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_reportErrRes(&mut self) -> Response_ReportAttestationErrorResponse {
        self.reportErrRes.take().unwrap_or_else(|| Response_ReportAttestationErrorResponse::new())
    }

    // optional .aesm.message.Response.GetWhiteListSizeResponse getWhiteListSizeRes = 10;


    pub fn get_getWhiteListSizeRes(&self) -> &Response_GetWhiteListSizeResponse {
        self.getWhiteListSizeRes.as_ref().unwrap_or_else(|| <Response_GetWhiteListSizeResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getWhiteListSizeRes(&mut self) {
        self.getWhiteListSizeRes.clear();
    }

    pub fn has_getWhiteListSizeRes(&self) -> bool {
        self.getWhiteListSizeRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getWhiteListSizeRes(&mut self, v: Response_GetWhiteListSizeResponse) {
        self.getWhiteListSizeRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getWhiteListSizeRes(&mut self) -> &mut Response_GetWhiteListSizeResponse {
        if self.getWhiteListSizeRes.is_none() {
            self.getWhiteListSizeRes.set_default();
        }
        self.getWhiteListSizeRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_getWhiteListSizeRes(&mut self) -> Response_GetWhiteListSizeResponse {
        self.getWhiteListSizeRes.take().unwrap_or_else(|| Response_GetWhiteListSizeResponse::new())
    }

    // optional .aesm.message.Response.GetWhiteListResponse getWhiteListRes = 11;


    pub fn get_getWhiteListRes(&self) -> &Response_GetWhiteListResponse {
        self.getWhiteListRes.as_ref().unwrap_or_else(|| <Response_GetWhiteListResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getWhiteListRes(&mut self) {
        self.getWhiteListRes.clear();
    }

    pub fn has_getWhiteListRes(&self) -> bool {
        self.getWhiteListRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getWhiteListRes(&mut self, v: Response_GetWhiteListResponse) {
        self.getWhiteListRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getWhiteListRes(&mut self) -> &mut Response_GetWhiteListResponse {
        if self.getWhiteListRes.is_none() {
            self.getWhiteListRes.set_default();
        }
        self.getWhiteListRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_getWhiteListRes(&mut self) -> Response_GetWhiteListResponse {
        self.getWhiteListRes.take().unwrap_or_else(|| Response_GetWhiteListResponse::new())
    }

    // optional .aesm.message.Response.SGXGetExtendedEpidGroupIdResponse sgxGetExtendedEpidGroupIdRes = 12;


    pub fn get_sgxGetExtendedEpidGroupIdRes(&self) -> &Response_SGXGetExtendedEpidGroupIdResponse {
        self.sgxGetExtendedEpidGroupIdRes.as_ref().unwrap_or_else(|| <Response_SGXGetExtendedEpidGroupIdResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sgxGetExtendedEpidGroupIdRes(&mut self) {
        self.sgxGetExtendedEpidGroupIdRes.clear();
    }

    pub fn has_sgxGetExtendedEpidGroupIdRes(&self) -> bool {
        self.sgxGetExtendedEpidGroupIdRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sgxGetExtendedEpidGroupIdRes(&mut self, v: Response_SGXGetExtendedEpidGroupIdResponse) {
        self.sgxGetExtendedEpidGroupIdRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sgxGetExtendedEpidGroupIdRes(&mut self) -> &mut Response_SGXGetExtendedEpidGroupIdResponse {
        if self.sgxGetExtendedEpidGroupIdRes.is_none() {
            self.sgxGetExtendedEpidGroupIdRes.set_default();
        }
        self.sgxGetExtendedEpidGroupIdRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_sgxGetExtendedEpidGroupIdRes(&mut self) -> Response_SGXGetExtendedEpidGroupIdResponse {
        self.sgxGetExtendedEpidGroupIdRes.take().unwrap_or_else(|| Response_SGXGetExtendedEpidGroupIdResponse::new())
    }

    // optional .aesm.message.Response.SGXSwitchExtendedEpidGroupResponse sgxSwitchExtendedEpidGroupRes = 13;


    pub fn get_sgxSwitchExtendedEpidGroupRes(&self) -> &Response_SGXSwitchExtendedEpidGroupResponse {
        self.sgxSwitchExtendedEpidGroupRes.as_ref().unwrap_or_else(|| <Response_SGXSwitchExtendedEpidGroupResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sgxSwitchExtendedEpidGroupRes(&mut self) {
        self.sgxSwitchExtendedEpidGroupRes.clear();
    }

    pub fn has_sgxSwitchExtendedEpidGroupRes(&self) -> bool {
        self.sgxSwitchExtendedEpidGroupRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sgxSwitchExtendedEpidGroupRes(&mut self, v: Response_SGXSwitchExtendedEpidGroupResponse) {
        self.sgxSwitchExtendedEpidGroupRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sgxSwitchExtendedEpidGroupRes(&mut self) -> &mut Response_SGXSwitchExtendedEpidGroupResponse {
        if self.sgxSwitchExtendedEpidGroupRes.is_none() {
            self.sgxSwitchExtendedEpidGroupRes.set_default();
        }
        self.sgxSwitchExtendedEpidGroupRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_sgxSwitchExtendedEpidGroupRes(&mut self) -> Response_SGXSwitchExtendedEpidGroupResponse {
        self.sgxSwitchExtendedEpidGroupRes.take().unwrap_or_else(|| Response_SGXSwitchExtendedEpidGroupResponse::new())
    }

    // optional .aesm.message.Response.SGXRegisterResponse sgxRegisterRes = 14;


    pub fn get_sgxRegisterRes(&self) -> &Response_SGXRegisterResponse {
        self.sgxRegisterRes.as_ref().unwrap_or_else(|| <Response_SGXRegisterResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sgxRegisterRes(&mut self) {
        self.sgxRegisterRes.clear();
    }

    pub fn has_sgxRegisterRes(&self) -> bool {
        self.sgxRegisterRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sgxRegisterRes(&mut self, v: Response_SGXRegisterResponse) {
        self.sgxRegisterRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sgxRegisterRes(&mut self) -> &mut Response_SGXRegisterResponse {
        if self.sgxRegisterRes.is_none() {
            self.sgxRegisterRes.set_default();
        }
        self.sgxRegisterRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_sgxRegisterRes(&mut self) -> Response_SGXRegisterResponse {
        self.sgxRegisterRes.take().unwrap_or_else(|| Response_SGXRegisterResponse::new())
    }

    // optional .aesm.message.Response.InitQuoteExResponse initQuoteExRes = 15;


    pub fn get_initQuoteExRes(&self) -> &Response_InitQuoteExResponse {
        self.initQuoteExRes.as_ref().unwrap_or_else(|| <Response_InitQuoteExResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_initQuoteExRes(&mut self) {
        self.initQuoteExRes.clear();
    }

    pub fn has_initQuoteExRes(&self) -> bool {
        self.initQuoteExRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initQuoteExRes(&mut self, v: Response_InitQuoteExResponse) {
        self.initQuoteExRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initQuoteExRes(&mut self) -> &mut Response_InitQuoteExResponse {
        if self.initQuoteExRes.is_none() {
            self.initQuoteExRes.set_default();
        }
        self.initQuoteExRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_initQuoteExRes(&mut self) -> Response_InitQuoteExResponse {
        self.initQuoteExRes.take().unwrap_or_else(|| Response_InitQuoteExResponse::new())
    }

    // optional .aesm.message.Response.GetQuoteSizeExResponse getQuoteSizeExRes = 16;


    pub fn get_getQuoteSizeExRes(&self) -> &Response_GetQuoteSizeExResponse {
        self.getQuoteSizeExRes.as_ref().unwrap_or_else(|| <Response_GetQuoteSizeExResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getQuoteSizeExRes(&mut self) {
        self.getQuoteSizeExRes.clear();
    }

    pub fn has_getQuoteSizeExRes(&self) -> bool {
        self.getQuoteSizeExRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getQuoteSizeExRes(&mut self, v: Response_GetQuoteSizeExResponse) {
        self.getQuoteSizeExRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getQuoteSizeExRes(&mut self) -> &mut Response_GetQuoteSizeExResponse {
        if self.getQuoteSizeExRes.is_none() {
            self.getQuoteSizeExRes.set_default();
        }
        self.getQuoteSizeExRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_getQuoteSizeExRes(&mut self) -> Response_GetQuoteSizeExResponse {
        self.getQuoteSizeExRes.take().unwrap_or_else(|| Response_GetQuoteSizeExResponse::new())
    }

    // optional .aesm.message.Response.GetQuoteExResponse getQuoteExRes = 17;


    pub fn get_getQuoteExRes(&self) -> &Response_GetQuoteExResponse {
        self.getQuoteExRes.as_ref().unwrap_or_else(|| <Response_GetQuoteExResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_getQuoteExRes(&mut self) {
        self.getQuoteExRes.clear();
    }

    pub fn has_getQuoteExRes(&self) -> bool {
        self.getQuoteExRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_getQuoteExRes(&mut self, v: Response_GetQuoteExResponse) {
        self.getQuoteExRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_getQuoteExRes(&mut self) -> &mut Response_GetQuoteExResponse {
        if self.getQuoteExRes.is_none() {
            self.getQuoteExRes.set_default();
        }
        self.getQuoteExRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_getQuoteExRes(&mut self) -> Response_GetQuoteExResponse {
        self.getQuoteExRes.take().unwrap_or_else(|| Response_GetQuoteExResponse::new())
    }

    // optional .aesm.message.Response.CheckUpdateStatusResponse checkUpdateStatusRes = 18;


    pub fn get_checkUpdateStatusRes(&self) -> &Response_CheckUpdateStatusResponse {
        self.checkUpdateStatusRes.as_ref().unwrap_or_else(|| <Response_CheckUpdateStatusResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_checkUpdateStatusRes(&mut self) {
        self.checkUpdateStatusRes.clear();
    }

    pub fn has_checkUpdateStatusRes(&self) -> bool {
        self.checkUpdateStatusRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checkUpdateStatusRes(&mut self, v: Response_CheckUpdateStatusResponse) {
        self.checkUpdateStatusRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checkUpdateStatusRes(&mut self) -> &mut Response_CheckUpdateStatusResponse {
        if self.checkUpdateStatusRes.is_none() {
            self.checkUpdateStatusRes.set_default();
        }
        self.checkUpdateStatusRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_checkUpdateStatusRes(&mut self) -> Response_CheckUpdateStatusResponse {
        self.checkUpdateStatusRes.take().unwrap_or_else(|| Response_CheckUpdateStatusResponse::new())
    }

    // optional .aesm.message.Response.SelectAttKeyIDResponse selectAttKeyIDRes = 19;


    pub fn get_selectAttKeyIDRes(&self) -> &Response_SelectAttKeyIDResponse {
        self.selectAttKeyIDRes.as_ref().unwrap_or_else(|| <Response_SelectAttKeyIDResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_selectAttKeyIDRes(&mut self) {
        self.selectAttKeyIDRes.clear();
    }

    pub fn has_selectAttKeyIDRes(&self) -> bool {
        self.selectAttKeyIDRes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selectAttKeyIDRes(&mut self, v: Response_SelectAttKeyIDResponse) {
        self.selectAttKeyIDRes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selectAttKeyIDRes(&mut self) -> &mut Response_SelectAttKeyIDResponse {
        if self.selectAttKeyIDRes.is_none() {
            self.selectAttKeyIDRes.set_default();
        }
        self.selectAttKeyIDRes.as_mut().unwrap()
    }

    // Take field
    pub fn take_selectAttKeyIDRes(&mut self) -> Response_SelectAttKeyIDResponse {
        self.selectAttKeyIDRes.take().unwrap_or_else(|| Response_SelectAttKeyIDResponse::new())
    }
}

impl ::protobuf::Message for Response {
    fn is_initialized(&self) -> bool {
        for v in &self.initQuoteRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getQuoteRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getLicTokenRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reportErrRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getWhiteListSizeRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getWhiteListRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sgxGetExtendedEpidGroupIdRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sgxSwitchExtendedEpidGroupRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sgxRegisterRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initQuoteExRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getQuoteSizeExRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.getQuoteExRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checkUpdateStatusRes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.selectAttKeyIDRes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.initQuoteRes)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getQuoteRes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getLicTokenRes)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reportErrRes)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getWhiteListSizeRes)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getWhiteListRes)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sgxGetExtendedEpidGroupIdRes)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sgxSwitchExtendedEpidGroupRes)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sgxRegisterRes)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.initQuoteExRes)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getQuoteSizeExRes)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.getQuoteExRes)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checkUpdateStatusRes)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selectAttKeyIDRes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.initQuoteRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getQuoteRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getLicTokenRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reportErrRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getWhiteListSizeRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getWhiteListRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sgxGetExtendedEpidGroupIdRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sgxSwitchExtendedEpidGroupRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.sgxRegisterRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.initQuoteExRes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getQuoteSizeExRes.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.getQuoteExRes.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checkUpdateStatusRes.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.selectAttKeyIDRes.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.initQuoteRes.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getQuoteRes.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getLicTokenRes.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reportErrRes.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getWhiteListSizeRes.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getWhiteListRes.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sgxGetExtendedEpidGroupIdRes.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sgxSwitchExtendedEpidGroupRes.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.sgxRegisterRes.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.initQuoteExRes.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getQuoteSizeExRes.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.getQuoteExRes.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checkUpdateStatusRes.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.selectAttKeyIDRes.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response {
        Response::new()
    }

    fn default_instance() -> &'static Response {
        static instance: ::protobuf::rt::LazyV2<Response> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response::new)
    }
}

impl ::protobuf::Clear for Response {
    fn clear(&mut self) {
        self.initQuoteRes.clear();
        self.getQuoteRes.clear();
        self.getLicTokenRes.clear();
        self.reportErrRes.clear();
        self.getWhiteListSizeRes.clear();
        self.getWhiteListRes.clear();
        self.sgxGetExtendedEpidGroupIdRes.clear();
        self.sgxSwitchExtendedEpidGroupRes.clear();
        self.sgxRegisterRes.clear();
        self.initQuoteExRes.clear();
        self.getQuoteSizeExRes.clear();
        self.getQuoteExRes.clear();
        self.checkUpdateStatusRes.clear();
        self.selectAttKeyIDRes.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response_InitQuoteResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    targetInfo: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    gid: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_InitQuoteResponse {
    fn default() -> &'a Response_InitQuoteResponse {
        <Response_InitQuoteResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_InitQuoteResponse {
    pub fn new() -> Response_InitQuoteResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes targetInfo = 2;


    pub fn get_targetInfo(&self) -> &[u8] {
        match self.targetInfo.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_targetInfo(&mut self) {
        self.targetInfo.clear();
    }

    pub fn has_targetInfo(&self) -> bool {
        self.targetInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetInfo(&mut self, v: ::std::vec::Vec<u8>) {
        self.targetInfo = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetInfo(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.targetInfo.is_none() {
            self.targetInfo.set_default();
        }
        self.targetInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetInfo(&mut self) -> ::std::vec::Vec<u8> {
        self.targetInfo.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes gid = 3;


    pub fn get_gid(&self) -> &[u8] {
        match self.gid.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_gid(&mut self) {
        self.gid.clear();
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: ::std::vec::Vec<u8>) {
        self.gid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gid(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.gid.is_none() {
            self.gid.set_default();
        }
        self.gid.as_mut().unwrap()
    }

    // Take field
    pub fn take_gid(&mut self) -> ::std::vec::Vec<u8> {
        self.gid.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_InitQuoteResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.targetInfo)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.gid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.targetInfo.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.gid.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.targetInfo.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.gid.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_InitQuoteResponse {
        Response_InitQuoteResponse::new()
    }

    fn default_instance() -> &'static Response_InitQuoteResponse {
        static instance: ::protobuf::rt::LazyV2<Response_InitQuoteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_InitQuoteResponse::new)
    }
}

impl ::protobuf::Clear for Response_InitQuoteResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.targetInfo.clear();
        self.gid.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_InitQuoteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response_GetQuoteResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    quote: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    qe_report: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_GetQuoteResponse {
    fn default() -> &'a Response_GetQuoteResponse {
        <Response_GetQuoteResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_GetQuoteResponse {
    pub fn new() -> Response_GetQuoteResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes quote = 2;


    pub fn get_quote(&self) -> &[u8] {
        match self.quote.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_quote(&mut self) {
        self.quote.clear();
    }

    pub fn has_quote(&self) -> bool {
        self.quote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote(&mut self, v: ::std::vec::Vec<u8>) {
        self.quote = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.quote.is_none() {
            self.quote.set_default();
        }
        self.quote.as_mut().unwrap()
    }

    // Take field
    pub fn take_quote(&mut self) -> ::std::vec::Vec<u8> {
        self.quote.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes qe_report = 3;


    pub fn get_qe_report(&self) -> &[u8] {
        match self.qe_report.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_qe_report(&mut self) {
        self.qe_report.clear();
    }

    pub fn has_qe_report(&self) -> bool {
        self.qe_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qe_report(&mut self, v: ::std::vec::Vec<u8>) {
        self.qe_report = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_qe_report(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.qe_report.is_none() {
            self.qe_report.set_default();
        }
        self.qe_report.as_mut().unwrap()
    }

    // Take field
    pub fn take_qe_report(&mut self) -> ::std::vec::Vec<u8> {
        self.qe_report.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_GetQuoteResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.quote)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.qe_report)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.quote.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.qe_report.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.quote.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.qe_report.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_GetQuoteResponse {
        Response_GetQuoteResponse::new()
    }

    fn default_instance() -> &'static Response_GetQuoteResponse {
        static instance: ::protobuf::rt::LazyV2<Response_GetQuoteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_GetQuoteResponse::new)
    }
}

impl ::protobuf::Clear for Response_GetQuoteResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.quote.clear();
        self.qe_report.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_GetQuoteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response_GetLaunchTokenResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_GetLaunchTokenResponse {
    fn default() -> &'a Response_GetLaunchTokenResponse {
        <Response_GetLaunchTokenResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_GetLaunchTokenResponse {
    pub fn new() -> Response_GetLaunchTokenResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes token = 2;


    pub fn get_token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_GetLaunchTokenResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.token.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.token.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_GetLaunchTokenResponse {
        Response_GetLaunchTokenResponse::new()
    }

    fn default_instance() -> &'static Response_GetLaunchTokenResponse {
        static instance: ::protobuf::rt::LazyV2<Response_GetLaunchTokenResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_GetLaunchTokenResponse::new)
    }
}

impl ::protobuf::Clear for Response_GetLaunchTokenResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.token.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_GetLaunchTokenResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response_ReportAttestationErrorResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    platform_update_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_ReportAttestationErrorResponse {
    fn default() -> &'a Response_ReportAttestationErrorResponse {
        <Response_ReportAttestationErrorResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_ReportAttestationErrorResponse {
    pub fn new() -> Response_ReportAttestationErrorResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes platform_update_info = 2;


    pub fn get_platform_update_info(&self) -> &[u8] {
        match self.platform_update_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_platform_update_info(&mut self) {
        self.platform_update_info.clear();
    }

    pub fn has_platform_update_info(&self) -> bool {
        self.platform_update_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_update_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.platform_update_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_platform_update_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.platform_update_info.is_none() {
            self.platform_update_info.set_default();
        }
        self.platform_update_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_platform_update_info(&mut self) -> ::std::vec::Vec<u8> {
        self.platform_update_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_ReportAttestationErrorResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.platform_update_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.platform_update_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.platform_update_info.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_ReportAttestationErrorResponse {
        Response_ReportAttestationErrorResponse::new()
    }

    fn default_instance() -> &'static Response_ReportAttestationErrorResponse {
        static instance: ::protobuf::rt::LazyV2<Response_ReportAttestationErrorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_ReportAttestationErrorResponse::new)
    }
}

impl ::protobuf::Clear for Response_ReportAttestationErrorResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.platform_update_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_ReportAttestationErrorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response_CheckUpdateStatusResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    platform_update_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    status: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_CheckUpdateStatusResponse {
    fn default() -> &'a Response_CheckUpdateStatusResponse {
        <Response_CheckUpdateStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_CheckUpdateStatusResponse {
    pub fn new() -> Response_CheckUpdateStatusResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes platform_update_info = 2;


    pub fn get_platform_update_info(&self) -> &[u8] {
        match self.platform_update_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_platform_update_info(&mut self) {
        self.platform_update_info.clear();
    }

    pub fn has_platform_update_info(&self) -> bool {
        self.platform_update_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_update_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.platform_update_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_platform_update_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.platform_update_info.is_none() {
            self.platform_update_info.set_default();
        }
        self.platform_update_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_platform_update_info(&mut self) -> ::std::vec::Vec<u8> {
        self.platform_update_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 status = 3;


    pub fn get_status(&self) -> u32 {
        self.status.unwrap_or(0)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Response_CheckUpdateStatusResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.platform_update_info)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.platform_update_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.platform_update_info.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.status {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_CheckUpdateStatusResponse {
        Response_CheckUpdateStatusResponse::new()
    }

    fn default_instance() -> &'static Response_CheckUpdateStatusResponse {
        static instance: ::protobuf::rt::LazyV2<Response_CheckUpdateStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_CheckUpdateStatusResponse::new)
    }
}

impl ::protobuf::Clear for Response_CheckUpdateStatusResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.platform_update_info.clear();
        self.status = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_CheckUpdateStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response_GetWhiteListSizeResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    white_list_size: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_GetWhiteListSizeResponse {
    fn default() -> &'a Response_GetWhiteListSizeResponse {
        <Response_GetWhiteListSizeResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_GetWhiteListSizeResponse {
    pub fn new() -> Response_GetWhiteListSizeResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional uint32 white_list_size = 2;


    pub fn get_white_list_size(&self) -> u32 {
        self.white_list_size.unwrap_or(0)
    }
    pub fn clear_white_list_size(&mut self) {
        self.white_list_size = ::std::option::Option::None;
    }

    pub fn has_white_list_size(&self) -> bool {
        self.white_list_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_white_list_size(&mut self, v: u32) {
        self.white_list_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Response_GetWhiteListSizeResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.white_list_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.white_list_size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.white_list_size {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_GetWhiteListSizeResponse {
        Response_GetWhiteListSizeResponse::new()
    }

    fn default_instance() -> &'static Response_GetWhiteListSizeResponse {
        static instance: ::protobuf::rt::LazyV2<Response_GetWhiteListSizeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_GetWhiteListSizeResponse::new)
    }
}

impl ::protobuf::Clear for Response_GetWhiteListSizeResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.white_list_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_GetWhiteListSizeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response_GetWhiteListResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    white_list: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_GetWhiteListResponse {
    fn default() -> &'a Response_GetWhiteListResponse {
        <Response_GetWhiteListResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_GetWhiteListResponse {
    pub fn new() -> Response_GetWhiteListResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes white_list = 2;


    pub fn get_white_list(&self) -> &[u8] {
        match self.white_list.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_white_list(&mut self) {
        self.white_list.clear();
    }

    pub fn has_white_list(&self) -> bool {
        self.white_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_white_list(&mut self, v: ::std::vec::Vec<u8>) {
        self.white_list = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_white_list(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.white_list.is_none() {
            self.white_list.set_default();
        }
        self.white_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_white_list(&mut self) -> ::std::vec::Vec<u8> {
        self.white_list.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_GetWhiteListResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.white_list)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.white_list.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.white_list.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_GetWhiteListResponse {
        Response_GetWhiteListResponse::new()
    }

    fn default_instance() -> &'static Response_GetWhiteListResponse {
        static instance: ::protobuf::rt::LazyV2<Response_GetWhiteListResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_GetWhiteListResponse::new)
    }
}

impl ::protobuf::Clear for Response_GetWhiteListResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.white_list.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_GetWhiteListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response_SGXGetExtendedEpidGroupIdResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    x_group_id: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_SGXGetExtendedEpidGroupIdResponse {
    fn default() -> &'a Response_SGXGetExtendedEpidGroupIdResponse {
        <Response_SGXGetExtendedEpidGroupIdResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_SGXGetExtendedEpidGroupIdResponse {
    pub fn new() -> Response_SGXGetExtendedEpidGroupIdResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional uint32 x_group_id = 2;


    pub fn get_x_group_id(&self) -> u32 {
        self.x_group_id.unwrap_or(0)
    }
    pub fn clear_x_group_id(&mut self) {
        self.x_group_id = ::std::option::Option::None;
    }

    pub fn has_x_group_id(&self) -> bool {
        self.x_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_group_id(&mut self, v: u32) {
        self.x_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Response_SGXGetExtendedEpidGroupIdResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.x_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.x_group_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x_group_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_SGXGetExtendedEpidGroupIdResponse {
        Response_SGXGetExtendedEpidGroupIdResponse::new()
    }

    fn default_instance() -> &'static Response_SGXGetExtendedEpidGroupIdResponse {
        static instance: ::protobuf::rt::LazyV2<Response_SGXGetExtendedEpidGroupIdResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_SGXGetExtendedEpidGroupIdResponse::new)
    }
}

impl ::protobuf::Clear for Response_SGXGetExtendedEpidGroupIdResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.x_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_SGXGetExtendedEpidGroupIdResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response_SGXSwitchExtendedEpidGroupResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_SGXSwitchExtendedEpidGroupResponse {
    fn default() -> &'a Response_SGXSwitchExtendedEpidGroupResponse {
        <Response_SGXSwitchExtendedEpidGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_SGXSwitchExtendedEpidGroupResponse {
    pub fn new() -> Response_SGXSwitchExtendedEpidGroupResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Response_SGXSwitchExtendedEpidGroupResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_SGXSwitchExtendedEpidGroupResponse {
        Response_SGXSwitchExtendedEpidGroupResponse::new()
    }

    fn default_instance() -> &'static Response_SGXSwitchExtendedEpidGroupResponse {
        static instance: ::protobuf::rt::LazyV2<Response_SGXSwitchExtendedEpidGroupResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_SGXSwitchExtendedEpidGroupResponse::new)
    }
}

impl ::protobuf::Clear for Response_SGXSwitchExtendedEpidGroupResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_SGXSwitchExtendedEpidGroupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response_SGXRegisterResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_SGXRegisterResponse {
    fn default() -> &'a Response_SGXRegisterResponse {
        <Response_SGXRegisterResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_SGXRegisterResponse {
    pub fn new() -> Response_SGXRegisterResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Response_SGXRegisterResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_SGXRegisterResponse {
        Response_SGXRegisterResponse::new()
    }

    fn default_instance() -> &'static Response_SGXRegisterResponse {
        static instance: ::protobuf::rt::LazyV2<Response_SGXRegisterResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_SGXRegisterResponse::new)
    }
}

impl ::protobuf::Clear for Response_SGXRegisterResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_SGXRegisterResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response_SelectAttKeyIDResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    selected_att_key_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_SelectAttKeyIDResponse {
    fn default() -> &'a Response_SelectAttKeyIDResponse {
        <Response_SelectAttKeyIDResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_SelectAttKeyIDResponse {
    pub fn new() -> Response_SelectAttKeyIDResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes selected_att_key_id = 2;


    pub fn get_selected_att_key_id(&self) -> &[u8] {
        match self.selected_att_key_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_selected_att_key_id(&mut self) {
        self.selected_att_key_id.clear();
    }

    pub fn has_selected_att_key_id(&self) -> bool {
        self.selected_att_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_att_key_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.selected_att_key_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selected_att_key_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.selected_att_key_id.is_none() {
            self.selected_att_key_id.set_default();
        }
        self.selected_att_key_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_selected_att_key_id(&mut self) -> ::std::vec::Vec<u8> {
        self.selected_att_key_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_SelectAttKeyIDResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.selected_att_key_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.selected_att_key_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.selected_att_key_id.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_SelectAttKeyIDResponse {
        Response_SelectAttKeyIDResponse::new()
    }

    fn default_instance() -> &'static Response_SelectAttKeyIDResponse {
        static instance: ::protobuf::rt::LazyV2<Response_SelectAttKeyIDResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_SelectAttKeyIDResponse::new)
    }
}

impl ::protobuf::Clear for Response_SelectAttKeyIDResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.selected_att_key_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_SelectAttKeyIDResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response_InitQuoteExResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    target_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub_key_id_size: ::std::option::Option<u64>,
    pub_key_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_InitQuoteExResponse {
    fn default() -> &'a Response_InitQuoteExResponse {
        <Response_InitQuoteExResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_InitQuoteExResponse {
    pub fn new() -> Response_InitQuoteExResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes target_info = 2;


    pub fn get_target_info(&self) -> &[u8] {
        match self.target_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_target_info(&mut self) {
        self.target_info.clear();
    }

    pub fn has_target_info(&self) -> bool {
        self.target_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.target_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.target_info.is_none() {
            self.target_info.set_default();
        }
        self.target_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_target_info(&mut self) -> ::std::vec::Vec<u8> {
        self.target_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 pub_key_id_size = 3;


    pub fn get_pub_key_id_size(&self) -> u64 {
        self.pub_key_id_size.unwrap_or(0)
    }
    pub fn clear_pub_key_id_size(&mut self) {
        self.pub_key_id_size = ::std::option::Option::None;
    }

    pub fn has_pub_key_id_size(&self) -> bool {
        self.pub_key_id_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pub_key_id_size(&mut self, v: u64) {
        self.pub_key_id_size = ::std::option::Option::Some(v);
    }

    // optional bytes pub_key_id = 4;


    pub fn get_pub_key_id(&self) -> &[u8] {
        match self.pub_key_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_pub_key_id(&mut self) {
        self.pub_key_id.clear();
    }

    pub fn has_pub_key_id(&self) -> bool {
        self.pub_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pub_key_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.pub_key_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pub_key_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.pub_key_id.is_none() {
            self.pub_key_id.set_default();
        }
        self.pub_key_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_pub_key_id(&mut self) -> ::std::vec::Vec<u8> {
        self.pub_key_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_InitQuoteExResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.target_info)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.pub_key_id_size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.pub_key_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.target_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.pub_key_id_size {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.pub_key_id.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.target_info.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(v) = self.pub_key_id_size {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.pub_key_id.as_ref() {
            os.write_bytes(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_InitQuoteExResponse {
        Response_InitQuoteExResponse::new()
    }

    fn default_instance() -> &'static Response_InitQuoteExResponse {
        static instance: ::protobuf::rt::LazyV2<Response_InitQuoteExResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_InitQuoteExResponse::new)
    }
}

impl ::protobuf::Clear for Response_InitQuoteExResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.target_info.clear();
        self.pub_key_id_size = ::std::option::Option::None;
        self.pub_key_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_InitQuoteExResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response_GetQuoteSizeExResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    quote_size: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_GetQuoteSizeExResponse {
    fn default() -> &'a Response_GetQuoteSizeExResponse {
        <Response_GetQuoteSizeExResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_GetQuoteSizeExResponse {
    pub fn new() -> Response_GetQuoteSizeExResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional uint32 quote_size = 2;


    pub fn get_quote_size(&self) -> u32 {
        self.quote_size.unwrap_or(0)
    }
    pub fn clear_quote_size(&mut self) {
        self.quote_size = ::std::option::Option::None;
    }

    pub fn has_quote_size(&self) -> bool {
        self.quote_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote_size(&mut self, v: u32) {
        self.quote_size = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Response_GetQuoteSizeExResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.quote_size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.quote_size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quote_size {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_GetQuoteSizeExResponse {
        Response_GetQuoteSizeExResponse::new()
    }

    fn default_instance() -> &'static Response_GetQuoteSizeExResponse {
        static instance: ::protobuf::rt::LazyV2<Response_GetQuoteSizeExResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_GetQuoteSizeExResponse::new)
    }
}

impl ::protobuf::Clear for Response_GetQuoteSizeExResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.quote_size = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_GetQuoteSizeExResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
pub struct Response_GetQuoteExResponse {
    // message fields
    errorCode: ::std::option::Option<u32>,
    quote: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    qe_report_info: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Response_GetQuoteExResponse {
    fn default() -> &'a Response_GetQuoteExResponse {
        <Response_GetQuoteExResponse as ::protobuf::Message>::default_instance()
    }
}

impl Response_GetQuoteExResponse {
    pub fn new() -> Response_GetQuoteExResponse {
        ::std::default::Default::default()
    }

    // required uint32 errorCode = 1;


    pub fn get_errorCode(&self) -> u32 {
        self.errorCode.unwrap_or(1u32)
    }
    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: u32) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // optional bytes quote = 2;


    pub fn get_quote(&self) -> &[u8] {
        match self.quote.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_quote(&mut self) {
        self.quote.clear();
    }

    pub fn has_quote(&self) -> bool {
        self.quote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quote(&mut self, v: ::std::vec::Vec<u8>) {
        self.quote = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quote(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.quote.is_none() {
            self.quote.set_default();
        }
        self.quote.as_mut().unwrap()
    }

    // Take field
    pub fn take_quote(&mut self) -> ::std::vec::Vec<u8> {
        self.quote.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes qe_report_info = 3;


    pub fn get_qe_report_info(&self) -> &[u8] {
        match self.qe_report_info.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_qe_report_info(&mut self) {
        self.qe_report_info.clear();
    }

    pub fn has_qe_report_info(&self) -> bool {
        self.qe_report_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qe_report_info(&mut self, v: ::std::vec::Vec<u8>) {
        self.qe_report_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_qe_report_info(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.qe_report_info.is_none() {
            self.qe_report_info.set_default();
        }
        self.qe_report_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_qe_report_info(&mut self) -> ::std::vec::Vec<u8> {
        self.qe_report_info.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Response_GetQuoteExResponse {
    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.errorCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.quote)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.qe_report_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.errorCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.quote.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(ref v) = self.qe_report_info.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.errorCode {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.quote.as_ref() {
            os.write_bytes(2, &v)?;
        }
        if let Some(ref v) = self.qe_report_info.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response_GetQuoteExResponse {
        Response_GetQuoteExResponse::new()
    }

    fn default_instance() -> &'static Response_GetQuoteExResponse {
        static instance: ::protobuf::rt::LazyV2<Response_GetQuoteExResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Response_GetQuoteExResponse::new)
    }
}

impl ::protobuf::Clear for Response_GetQuoteExResponse {
    fn clear(&mut self) {
        self.errorCode = ::std::option::Option::None;
        self.quote.clear();
        self.qe_report_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::protobuf::reflect::ProtobufValue for Response_GetQuoteExResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}
